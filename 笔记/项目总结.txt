众筹
	认证的过程
	当查询流程定义数据的时候，返回的是json数据，对象之间的相互依赖导致json数据结构出错，JSON数据映射异常：
解决问题：
将List中数据使用Map存储，然后进行JSON数据格式化
返回的是result：boolean msg  data  page page可能出问题

	许可树：权限（广告审核、认证审核）（父子关系：json里套json，id和pid确定谁是子谁是父，返回的是数组，而不是对象）
	permission实体类（父）加了一个子 list children
	5个demo ：demo1：设置父 设置子 把子设置到父中，先让他显示出来；
demo2：从数据库查找父，根据父查找子，只能解决一层深度的；
demo3：用递归：每次查询都要发送sql语句，效率低，还可以进行进一步处理MyISAM查询性能比InnoDB更快，但不支持事务处理，
demo4：一次性查询所有权限。循环所有数据，找到子，根据子找父：外层循环100次，那么内层循环也需要100次；
demo5：第一次查找子放到map中 ，第二次从map里获取子，添加为父。

	登录
先判断是会员还是管理员，然后记住我，然所后加载当前用户拥有的权限，把路径放到session中。
逆向工程Example和pagehelper插件不兼容
jwt被盗，不能设置过期时间，


ebuy
	秒杀方案：
	1、确定一个基准时间。可以使用一个 sql 语句从数据库中取出一个当前时间。SELECT 
NOW()；
2、活动开始的时间是固定的。
3、使用活动开始时间-基准时间可以计算出一个秒为单位的数值。
4、在 redis 中设置一个 key（活动开始标识）。设置 key 的过期时间为第三步计算出来的时间。
5、展示页面的时候取出 key 的有效时间。Ttl 命令。使用 js 倒计时。
6、一旦活动开始的 key 失效，说明活动开始。
7、需要在活动的逻辑中，先判断活动是否开始。
6）、

1、把商品的数量放到 redis 中。
2、秒杀时使用 decr 命令对商品数量减一。如果不是负数说明抢到。
3、一旦返回数值变为 0 说明商品已售完。

	

	面试中的购物车处理方案
未登录可以使用购物车，在cookie中存储一个标识（token），设定cookie的时间。将购物车信息存储在redis中，key使用token，设定key的存活时间和cookie的存活时间一致。
登录状态下，将购物车信息存储在数据库中。

	sso
	登录后，把登录信息放到cookie中，uuid（16位），放到当前域名下，但是别的域名无法访问。
	jsonp
	js加载js文件，如果有callback这个函数，则说明存在跨域请求，拼接一个函数调用的js字符串。

十次方
	网关：
为什么需要微服务网关 不同的微服务一般有不同的网络地址，而外部的客户端可能需要调用多个服务的接口才 能完成一个业务需求。
比如一个电影购票的收集APP,可能回调用电影分类微服务，用户 微服务，支付微服务等。如果客户端直接和微服务进行通信，会存在一下问题： 
# 客户端会多次请求不同微服务，增加客户端的复杂性 
# 存在跨域请求，在一定场景下处理相对复杂 
# 认证复杂，每一个服务都需要独立认证 
# 难以重构，随着项目的迭代，可能需要重新划分微服务，如果客户端直接和微服务通 信，那么重构会难以实施 
# 某些微服务可能使用了其他协议，直接访问有一定困难 上述问题，都可以借助微服务网关解决。微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关。
	依赖注入方式：	
	过滤器：
	id生成器：twitter 雪花算法。（1位自增列+41位时间戳+10位工作机器id+12位序列号）
	nativcequery：可以执行原生sql语句。
	查询文章用redis；
	findbyid的时候：article = articleDao.findById(id).get();
@Cacheable-------使用这个注解的方法在执行后会缓存其返回结果。 
@CacheEvict--------使用这个注解的方法在其执行前或执行后移除Spring Cache中的某些 元素。
@CrossOrigin-------解决跨域问题
	mongodb（bson格式，介于关系型与非关系型，查询快，支持建立索引；数据库-数据库，集合-表，文档-数据行；db.spit.update({_id:"1"},{visits:NumberInt(1000)})；$in）：	
吐槽和评论：价值低、数据量大、写入操作频繁。
点赞，增删改查，增加浏览量与分享数。从redis中查找判断是否点过赞，点过不能再点；
	restful：get查询，post带参数的查询，put更新，delete删除
	所搜文章	
搜索引擎：elasticsearch，添加商品时发送rabbitmq消息，写一个监听器，调用方法同步到索引库。
	rabbitmq：高可用，在集群中的机器上进行镜像，使得在部分节点出现问题的情况下队列仍然可用。分列模式：讲一个消息发送到几个队列；主题模式，根据routing key进行模糊匹配。
	发送手机验证码：生成验证码存到redis，rabbitmq携带验证码和手机号通知发送信息，阿里云通信进行发送。
	登录	
使用jwt进行鉴权验证，避免代码冗余，写个拦截器。
	SpringCloud主要框架 
服务发现――Netflix Eureka 
服务调用――Netflix Feign 
熔断器――Netflix Hystrix 
服务网关――Netflix Zuul微服务工程统一入口，方便前端调用
分布式配置――Spring Cloud Config集中配置管理 
消息总线 ―― Spring Cloud Bus刷新配置
Eureka：相当于dubbo。
	你在项目中使用SpringCloud的哪些组件? 
服务注册组件Eureka 服务发现组件Feign 熔断器 网关 SpringCloudConfig (集中配置 管理) SpringCloudBus(消息总线) 你在项目中哪个业务场景使用到微服务间的调用 
交友微服务 添加好友，在交友微服务中调用用户微服务的更改粉丝数与关注数的方法。
	熔断器：防止雪崩效应，feign组件中，@FeignClient(value="tensquare┸base",fallback = LabelClientImpl.class)
	Dockerfile：一系列命令组成的脚本，创建镜像（环境和服务做成一个容器叫镜像，提供一致性环境），然后把镜像上传到docker私有仓库。

	
	




